<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Phaser - Making your first game, part 1</title>
    <script src="//cdn.jsdelivr.net/phaser/2.2.2/phaser.min.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>

<script type="text/javascript">
    var game = new Phaser.Game(800, 600, Phaser.AUTO, '', { preload: preload, create: create, update: update});
    function preload() {
        game.load.image('phaser', 'phaser.png');
    }

    var graphics;

    var p1_head;
    var p1_body;

    var lastX;
    var lastY;

    var directionAngle;

    function create() {
        graphics = game.add.graphics(0, 0);

        graphics.beginFill(0xFF3300);
        //graphics.lineStyle(10, 0xffd900, 1);

        graphics.drawCircle(0,0,15);

        //  Then generate a texture from it and apply the texture to the sprite
        p1_head = game.add.sprite(400, 300, graphics.generateTexture());
        p1_head.anchor.set(0.5);
        game.physics.arcade.enable(p1_head);
        p1_head.body.collideWorldBounds = true;



        p1_body = game.add.group();



        //  And destroy the original graphics object
        graphics.destroy();

        directionAngle = 0;

    }

    function update() {
        var angVel = 0.04; // Rads per update.
        var speed = 85;

        updateBody();

        var angleToPointer = game.physics.arcade.angleToPointer(p1_head);
        directionAngle = updateDirection(directionAngle, angleToPointer, angVel);

        p1_head.body.velocity.x = speed * Math.cos(directionAngle);
        p1_head.body.velocity.y = speed * Math.sin(directionAngle);

        game.physics.arcade.collide(p1_head,p1_body);

    }

    /**
     * 1. Draw line from last pos to current.
     * 2. Draw a circle at the end of the line to avoid edges.
     * 2. Make into sprite.
     * 3. Add sprite to group.
     */
    function updateBody(){

        graphics = game.add.graphics(0, 0);
        graphics.beginFill(0xFFD900);
        graphics.lineStyle(5, 0xFFD900, 1);
        graphics.moveTo(lastX,lastY);
        graphics.lineTo(p1_head.x,p1_head.y);
        graphics.drawCircle(p1_head.x, p1_head.y, 2.5);
        graphics.endFill();

        var sprite = game.add.sprite(p1_head.x, p1_head.y, graphics.generateTexture());
        graphics.destroy();

        game.physics.arcade.enable(sprite);
        sprite.body.immovable = true;
        sprite.anchor.set(0.5);
        p1_body.add(sprite);

        lastX = p1_head.x;
        lastY = p1_head.y;
    }

    /**
     * Takes an angle and returns it closer to the target angle.
     * @param currentAngle
     * @param targetAngle
     * @param angularVelocity
     * @returns {*}
     */
    function updateDirection(currentAngle, targetAngle, angularVelocity) {
        targetAngle = game.math.normalizeAngle(targetAngle);

        var difference = targetAngle - currentAngle;


        if(0 < difference ) {
            if ( difference < Math.PI )
                currentAngle += angularVelocity;
            else
                currentAngle -= angularVelocity;
        } else {
            if ( difference < -Math.PI )
                currentAngle += angularVelocity;
            else
                currentAngle -= angularVelocity;
        }

        currentAngle = game.math.wrapAngle(currentAngle, true);
        currentAngle = game.math.normalizeAngle(currentAngle);
        return currentAngle;
    }


</script>

</body>
</html>